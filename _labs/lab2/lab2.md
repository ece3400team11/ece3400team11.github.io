---
layout: blank
title:  "Lab 2"
subtitle: "Analog Circuitry and FFTs"
preview: "assets/images/lab2.png"
---

# Lab 2: Analog Circuitry and FFTs

## Acoustic Harware Construction
To build the acoustic setup, we first used the diagram given to us in the lab handout to setup the microphone. We then confirmed that the microphone was working by hooking up the oscilloscope to it and then playing a random tone. Originally, we were only measuring a peak-to-peak voltage of about 20 mV which would be too low to read directly on the Arduino. We decided to build an amplifier for our microphone circuit.

We first decided to connect the microphone to an inverting amplifier, but quickly discovered it to not work. Since our initial microphone circuit had a high DC offset, it railed the op-amp and the signal didn’t get amplified. To fix this, we looked into creating an amplifier that had more capacitors to get around are unusual DC offset. We used an LM358P op-amp and initially used the values shown below. However, we had to change a few of the component valued to optimize it for our circuit.
![Image](labs/lab2/images/og_microphone.jpg)
![Image](labs/lab2/images/updated_mic.JPG)

To get rid of all the harmonic signals generated from playing a tone, we added a low-pass filter that would only let signals below 700 Hz pass through. We used a 22 KOhm resistor with a 10 nF capacitor to accomplish this. The filter will also be useful in a noisy environment where other frequencies will be present. 
![Image](labs/lab2/images/lowpass.JPG)

Here is what the waveform looks like when the 660 Hz tone is played.
![Image](labs/lab2/images/mic_wave.jpg)

In the future, we may want to adjust our microphone amplifier more to get a cleaner output signal so it is easier to read on the arduino. We are also considering the option of using an external chip to do our FFTs so that our Arduino does not need to waste time doing this and can instead work on other important computations.


## IR Harware Construction

Here is a picture of the materials we were given:
![Image](labs/lab2/images/ir_parts_list.jpg)

We first built the simple series circuit shown in the online lab writeup. We then confirmed that the simple circuit was able to detect other robots by hooking up the IR hat to the power supply and powering it with 9V as specified in the lab writeup. As you can see from the oscillosope image of the waveform generated by the IR sensor, we were able to verify that the IR hat was indeed outputting a 6.08kHz signal. However, the waveform was definitely not sinusoidal, so we knew there would be plenty of error harmonics.
![Image](labs/lab2/images/hatwaveform1.jpg)

After we accomplished this, we decided to add a simple RC low pass filter to our circuit in order to filter out frequencies higher than our sampling rate (which could “look” like the 6.08 KHz signal after performing FFT). We decided to set the filter cutoff frequency at about 7 KHz which should let the IR hat signal through but exponentially dampen every frequency higher than that. We ended up using a 1 nF capacitor and a 22 KOhm resistor for the low pass filter.

We also noticed that the voltage in the IR signal could be quite low when the IR hat was more than a few inches away. Therefore, we decided to build a simple non-inverting op amp with a target gain of around 2. We initially had some difficulties getting the non-inverting op amp to work correctly. At first we used the LF353 in an non inverting configuration but we never saw an amplified signal on the op amp; only a constant voltage at around 4.3 volts (not quite the voltage on the Vcc rail). After trying a few different 353 ICs, we tried switching to the LM358 op amp and our amplification circuit immediately worked. We are still unsure why the 353s weren’t working. We decided to use an 12 KOhm resistor as R1 and a 18 KOhm resistor as R2, giving a gain of about 1+18/12 = 2.5.

We then gathered FFT data from the oscilloscope for when an IR hat was placed near the sensor. As expected, there is a definative fundamental frequency at around 6 kHz and many error harmonics at higher frequencies.
![Image](labs/lab2/images/hatfft.jpg)

We compared that data with the FFT data for when a decoy was brought close to the sensor and noticed a strong fundamental frequency at around 18 kHz.
![Image](labs/lab2/images/decoyfft.jpg)
  
The final circuit combines the op-amp with the low pass filter:
![Image](labs/lab2/images/IR_Detector_Circuit.jpg)
And here is the fully constructed circuit on a breaboard:
![Image](labs/lab2/images/IR_Detector_Circuit IRL.jpg)

## FFT Software

Finally, we used the FFT library for the Arduino to measure the IR and audio signal from port A0 and generate the amplitudes in the frequency bins using the following code:

```cpp
for (int i = 0 ; i < 512 ; i += 2) { // save 256 samples
  while(!(ADCSRA & 0x10)); // wait for adc to be ready
  ADCSRA = 0xf7; // restart adc
  byte m = ADCL; // fetch adc data
  byte j = ADCH;
  int k = (j << 8) | m; // form into an int
  k -= 0x0200; // form into a signed int
  k <<= 6; // form into a 16b signed int
  fft_input[i] = k; // put real data into even bins
  fft_input[i+1] = 0; // set odd bins to 0
}
fft_window(); // window the data for better frequency response
fft_reorder(); // reorder the data before doing the fft
fft_run(); // process the data in the fft
fft_mag_log(); // take the output of the fft
sei();
Serial.println("start");
for (byte i = 0 ; i < FFT_N/2 ; i++) { 
  Serial.println(fft_log_out[i]); // send out the data
}
```

We also added some additional setup code to have more control over how fast the ADC sampled data:

```cpp
TIMSK0 = 0; // turn off timer0 for lower jitter
ADCSRA = 0xe7; // set the adc to free running mode
ADMUX = 0x40; // use adc0
DIDR0 = 0x01; // turn off the digital input for adc0
```

The 7 at the end of the `ADCSRA` corresponds to the ADC clock prescalar, which determines how fast it samples data. This is important to tune so that you get proper frequency resolution for the frequencies that you are interested in. For example, we used a prescalar of 7 for the acustic FFT and a prescalar of 6 for the IR fft since the IR signal was at a much higher frequency (therefore we need a higher sampling rate).

We then used some matlab code to read the fft bin data from the arduino and plot the bin number vs. bin amplitude. This allowed us to visually inspect the result of the FFT analysis and figure out the bin number that corresponded with the 6.08K Hz signal and what a reasonable threshold should be to distinguish a signal from background noise. 

```matlab
myserialport = serial("/dev/cu.wchusbserial1410", "BaudRate", 9600)
fopen(myserialport)
binNums = [0:127];
bins = zeros(1,128);
try
    while 1
    start = fscanf(myserialport,"%s");
    if start == "start"
       break 
    end
    end
    for i = 1:128
        bins(i) = fscanf(myserialport,"%d")
    end
catch ME
    warning('error occured');
end
fclose(myserialport)
plot(binNums, bins)
```

We used matlab's `seriallist` to get a list of the ports we were using and figure out which one the arduino was connected to.

We ran the matlab code while the arduino was connected to the IR sensor and got the following plot when no IR hats were nearby:
![Image](labs/lab2/images/irbgd.png)

We then ran the matlab code with an IR hat a few inches away from the sensor and got the following plot:
![Image](labs/lab2/images/iropampout.png)

From that plot we were able to determine that the primary bin we should be checking was bin number 84 and that we should set the threshold for detecting another IR hat at about 60. We then incorporated this thresholding with an LED in order to visualize when the arduino detects another robot. Here is a video of the full IR circuit where the red LED shows if the arduino has detected another robot:
<iframe width="560" height="315" src="https://www.youtube.com/embed/cwhYxnZrcJQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

## Full lab code

You can find the full code that we used in this lab [here](https://github.com/ece3400team11/ece3400team11.github.io/tree/master/_labs/lab2/code)
